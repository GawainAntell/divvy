% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/subsample_MST.R
\name{clustr}
\alias{clustr}
\title{Cluster localities within regions of nearest neighbours}
\usage{
clustr(dat, xy, distMax, nSite = NULL, iter, nMin = 3, output = "locs")
}
\arguments{
\item{dat}{A \code{data.frame} or \code{matrix} containing the
coordinate columns \code{xy} and any associated variables, e.g. taxon names.}

\item{xy}{A vector of two elements, specifying the name or numeric position
of the columns containing longitude and latitude coordinates, respectively.}

\item{distMax}{Numeric value for maximum diameter (km) allowed across
locations in a subsample}

\item{nSite}{The quota of unique locations to include in each subsample.}

\item{iter}{The number of spatial subsamples to return}

\item{nMin}{Numeric value for the minimum number of sites to be included in
every returned subsample. If \code{nSite} supplied, \code{nMin} ignored.}

\item{output}{Whether the returned data should be a two-column matrix of
subsample site coordinates (\code{output = 'locs'}) or the subset of rows
from \code{dat} associated with those coordinates (\code{output = 'full'}).}
}
\description{
Spatially subsample a dataset based on minimum spanning trees connecting
points within regions of set extent, with optional rarefaction to a site quota.
}
\details{
Lagomarcino and Miller (2012) developed an iterative approach of aggregating
localities to build clusters based on convex hulls, inspired by species-area
curve analysis (Scheiner 2003). Close et al. (2017, 2020) refined the approach and
changed the proximity metric from minimum convex hull area to minimum spanning
tree length. The present implementation adapts code from Close et al. (2020)
to add an option for site rarefaction after cluster construction and to grow
trees at random starting points \code{iter} number of times (instead of a
deterministic, exhaustive iteration at every unique location).

The function takes a single location as a starting (seed) point; the seed
and its nearest neighbour initiate a spatial cluster. The distance between
the two points is the first branch in a minimum spanning tree for the cluster.
The location that has the shortest distance to any points already within the
cluster is grouped in next, and its distance (branch) is added to the sum
tree length. This iterative process continues until the largest distance
between any two points in the cluster would exceed \code{distMax} km.
In the very rare case multiple candidate points are tied for minimum distance
from the cluster, one point is selected at random as the next to include.
Any tree with fewer than \code{nMin} points is prohibited.

In the case that \code{nSite} is supplied, \code{nMin} argument is ignored,
and any tree with fewer than \code{nSite} points is prohibited.
After building a tree as described above, a random set of \code{nSite} points
within the cluster is taken (without replacement). The returned output is
the coordinates of subsampled points if \code{output = 'locs'} or the subset
of \code{dat} associated with those coordinates if \code{output = 'full'}.
The \code{nSite} argument makes \code{clustr} comparable with \code{cookies}
in that it spatially standardises both extent and area/locality number.

The performance of \code{clustr} is designed on the assumption \code{iter}
is much larger than the number of unique localities. Internal code first
calculates the full minimum spanning tree at every viable starting point
before it then samples those trees (i.e. resamples and optionally subsamples)
for the specified number of iterations. This sequence means the total
run-time increases only marginally even as \code{iter} increases greatly.
However, if there are a large number of sites, particularly a large number
of densely-spaced sites, the calculations will be slow even for a
small number of iterations.
}
\references{
\insertRef{Antell2020}{divvy}

\insertRef{Close2017}{divvy}

\insertRef{Close2020}{divvy}

\insertRef{Lagomarcino2012}{divvy}

\insertRef{Scheiner2003}{divvy}
}
\seealso{
\code{\link[=cookies]{cookies()}}
}
