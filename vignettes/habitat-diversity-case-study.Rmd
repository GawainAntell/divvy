---
title: "Environment and latitude standardisation case study"
author: "G. S. Antell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import data

See separate script (format-silurian-data.R) for download and cleaning of raw data.
```{r imports, message=FALSE}
library(divvy) 
library(terra) 
library(sf)
data(collSilur)
data(occSilur)
```

# Standardise environmental categorisation

```{r data cleanup}
# do not make inference for mixed lithologies
# otherwise, mixed lithology will be overwritten as siliciclastic
  # binned$lithology1[grep('mixed', binned$lithology1)] <- NA 

# The following section is modified from Nurnberg and Aberhan (2013)
# and as written in Antell et al (2020)

# Define variables for search 
  # carb <- c("\"carbonate\"", "\"limestone\"", "\"reef rocks\"", "bafflestone", "bindstone", "dolomite", 
  #           "framestone", "grainstone", "lime mudstone", "packstone", "rudstone", "floatstone",
  #           "wackestone")
  # clast <- c("\"shale\"", "\"siliciclastic\"", "\"volcaniclastic\"", "claystone", "conglomerate",  
  #            "mudstone", "phyllite", "quartzite", "sandstone", "siltstone", "slate", "schist")
proxTerms <- c("coastal indet.", "delta front", "delta plain",
               "deltaic indet.", "estuary/bay", "foreshore", "interdistributary bay",
               "lagoonal", "lagoonal/restricted shallow subtidal",
               "marginal marine indet.", "open shallow subtidal", "fluvial-deltaic indet.",
               "paralic indet.", "peritidal", "prodelta", "sand shoal",
               "shallow subtidal indet.", "shoreface", "transition zone/lower shoreface",
               "intrashelf/intraplatform reef", "reef, buildup or bioherm",
               "perireef or subreef", "platform/shelf-margin reef") # last 2 lines include reefs
deepTerms <- c("basinal (carbonate)", "basinal (siliceous)", "basinal (siliciclastic)",
               "deep-water indet.", "deep subtidal indet.", "deep subtidal ramp",
               "deep subtidal shelf", "offshore", "offshore indet.",
               "offshore shelf", "slope", "submarine fan", "offshore ramp", 
               "basin reef", "slope/ramp reef") # last line includes deep water reefs

# Lithology
  # l[binned$lithology1 %in% carb] <- "c"  
  # l[binned$lithology1 %in% clast] <- "s"

# Bathymetry
collSilur$bath <- NA
collSilur$bath[collSilur$environment %in% proxTerms] <- 'prox.' 
collSilur$bath[collSilur$environment %in% deepTerms] <- 'deep'
```

# Determine environment in cells and environmental preferences in taxa

- Omit duplicate occurrences?

Rasterise points (should be equal area once projection supported)
```{r rasterise}
ll <- rast(resolution = 5, crs = 'epsg:4326')
prj <- 'ESRI:54030' # Robinson 
# 'EPSG:8858' # "+proj=moll" # 'EPSG:8857' equal earth
rob <- project(ll, prj) 
values(rob) <- 1:ncell(rob)

xyCartes <- c('paleolng','paleolat')
llColl <- vect(collSilur, geom = xyCartes, crs = 'epsg:4326')
robColl <- project(llColl, prj)
cellMat <- cells(rob, robColl) 
collSilur$cell <- cellMat[,'cell']
xyRob <- xyFromCell(rob, collSilur$cell)
cellXY <- c('cellX','cellY')
collSilur[,cellXY] <- xyRob
```

```{r plot enviro raster, fig.width=5.5, fig.align='center'}
bathRast <- classRast(rob, dat = collSilur, cutoff = 0.8,
                      xy = cellXY, env = 'bath')
plot(bathRast)
```

# Spatial standardisation of area and latitude

Split data by enviro category
```{r split occs by enviro class}
# infer environment of each occurrence
llOccs <- vect(occSilur, geom = xyCartes, crs = 'epsg:4326')
robOccs <- project(llOccs, prj)
occSilur$cell <- cells(rob, robOccs)[,'cell']
occSilur[,cellXY] <- xyFromCell(rob, occSilur$cell)
occSilur$bath <- extract(bathRast, robOccs)[['mainClass']] |> as.character()
deep <- occSilur[occSilur$bath == 'deep',]
prox <- occSilur[occSilur$bath == 'prox.',]
```

Regionally subsample each occurrence subset. 
Don't weight - not enough pool cells to matter much anyway.
```{r, error=TRUE}
reps <- 500
siteQuota <- 10
siteCol <- 'cell'
r <- 1000 # radial distance in km
sampD <- cookies(dat = deep, 
                  xy = cellXY, iter = reps, 
                  nSite = siteQuota, 
                  siteId = siteCol, r = r, 
                  crs = prj, output = 'full')
# we have to expand the subsample bounds to get enough sites!
r <- 1500
sampD <- cookies(dat = deep, 
                 xy = cellXY, iter = reps, 
                 nSite = siteQuota, 
                 siteId = siteCol, r = r, 
                 crs = prj, output = 'full')

# plot(bathRast)
# proxPts <- robOccs[robOccs$bath=='prox.',]
# points(proxPts)
sampP <- cookies(dat = prox, 
                 xy = cellXY, iter = reps, 
                 nSite = siteQuota, 
                 siteId = siteCol, r = r, 
                 crs = prj, output = 'full')
```

# Compare geographic range size across environments

```{r}
metaD <- sdsumry(dat = sampD, taxVar = 'genus', xy = cellXY, crs = prj)
metaP <- sdsumry(dat = sampP, taxVar = 'genus', xy = cellXY, crs = prj)
metaD$occAvg <- metaD$nOcc/metaD$nTax
metaP$occAvg <- metaP$nOcc/metaP$nTax
```

```{r boxplots, message = FALSE}
library(ggplot2)
plotDat <- rbind(metaD, metaP)
plotDat$bath <- c(rep('deep', nrow(metaD)), 
                  rep('prox', nrow(metaP)))
pBase <- ggplot(plotDat, aes(x = bath))
pBase + geom_boxplot(aes(x = bath, y = occAvg))
```

```{r deep-prox comparison}
# check out correlations betweeen all pairs of variables
vars <- c('minSpanTree','SCOR','occAvg','nTax')
cor(metaD[,vars], method = 'kendall')

# order subsample pairs by agg for fairer comparison?
# sample agg correlates with richness, for example
ordrD <- order(metaD$minSpanTree)
ordrP <- order(metaP$minSpanTree)
metaD <- metaD[ordrD,]
metaP <- metaP[ordrP,]

richPair <- sum(metaP$nTax > metaD$nTax) # H: prox > deep
richTestStat <- richPair / reps

# are ranges broader in the deep?
occPair <- sum(metaD$occAvg > metaP$occAvg) # H: deep > prox
occTestStat <- occPair / reps
```

```{r null distribution}
# NB: sorting strongly condenses the range of test statistic values
# and shifts from 0.5 to slightly less (because introduces ties (?))
nullSim <- function(dat1, dat2, vTest, vSort = NULL){
  # shuffle labels between test groups
  allDat <- rbind(dat1, dat2)
  n <- nrow(allDat) / 2
  hlf <- sample(sample(1:n*2), n, replace = FALSE)
  dat1null <- allDat[ hlf,]
  dat2null <- allDat[-hlf,]
  
  # optionally sort by second (sampling) variable
  if (! is.null(vSort)){
    ordr1 <- order(dat1null[, vSort])
    ordr2 <- order(dat2null[, vSort])
    dat1null <- dat1null[ordr1,]
    dat2null <- dat2null[ordr2,]
  }
  
  # (re)calculate test statistic
  v1null <- dat1null[, vTest]
  v2null <- dat2null[, vTest]
  sum(v2null > v1null) / n
}

# direction of test hypothesis (above code) assumes group 2 values > group 1
nullN <- 1000
nullTax <- replicate(nullN, nullSim(metaD, metaP, vTest = 'nTax')) # , vSort = 'minSpanTree'
hist(nullTax, xlim = c(0.4, 0.7))
abline(v = richTestStat, col = 'blue')
# test distribution shifted slightly left because there can be ties between groups
ci95 <- c(0.025, 0.975)
quantile(nullTax, ci95) 
sum(richTestStat > nullTax) / nullN

nullOcc <- replicate(nullN, nullSim(metaP, metaD, vTest = 'nOcc')) # , vSort = 'minSpanTree'
hist(nullOcc, xlim = c(0.4, 0.7))
abline(v = occTestStat, col = 'blue')
quantile(nullOcc, ci95)
sum(occTestStat > nullOcc) / nullN
```

