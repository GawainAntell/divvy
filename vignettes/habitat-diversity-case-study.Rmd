---
title: "Environment and latitude standardisation case study"
author: "G. S. Antell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import data

See separate script (format-silurian-data.R) for download and cleaning of raw data.
```{r imports, message=FALSE}
library(divvy) 
library(terra) 
library(sf)
data(collSilur)
data(occSilur)
```

# Standardise environmental categorisation

```{r data cleanup}
# do not make inference for mixed lithologies
# otherwise, mixed lithology will be overwritten as siliciclastic
  # binned$lithology1[grep('mixed', binned$lithology1)] <- NA 

# The following section is modified from Nurnberg and Aberhan (2013)
# and as written in Antell et al (2020)

# Define variables for search 
  # carb <- c("\"carbonate\"", "\"limestone\"", "\"reef rocks\"", "bafflestone", "bindstone", "dolomite", 
  #           "framestone", "grainstone", "lime mudstone", "packstone", "rudstone", "floatstone",
  #           "wackestone")
  # clast <- c("\"shale\"", "\"siliciclastic\"", "\"volcaniclastic\"", "claystone", "conglomerate",  
  #            "mudstone", "phyllite", "quartzite", "sandstone", "siltstone", "slate", "schist")
proxTerms <- c("coastal indet.", "delta front", "delta plain",
               "deltaic indet.", "estuary/bay", "foreshore", "interdistributary bay",
               "lagoonal", "lagoonal/restricted shallow subtidal",
               "marginal marine indet.", "open shallow subtidal", "fluvial-deltaic indet.",
               "paralic indet.", "peritidal", "prodelta", "sand shoal",
               "shallow subtidal indet.", "shoreface", "transition zone/lower shoreface",
               "intrashelf/intraplatform reef", "reef, buildup or bioherm",
               "perireef or subreef", "platform/shelf-margin reef") # last 2 lines include reefs
deepTerms <- c("basinal (carbonate)", "basinal (siliceous)", "basinal (siliciclastic)",
               "deep-water indet.", "deep subtidal indet.", "deep subtidal ramp",
               "deep subtidal shelf", "offshore", "offshore indet.",
               "offshore shelf", "slope", "submarine fan", "offshore ramp", 
               "basin reef", "slope/ramp reef") # last line includes deep water reefs

# Lithology
  # l[binned$lithology1 %in% carb] <- "c"  
  # l[binned$lithology1 %in% clast] <- "s"

# Bathymetry
collSilur$bath <- NA
collSilur$bath[collSilur$environment %in% proxTerms] <- 'prox.' 
collSilur$bath[collSilur$environment %in% deepTerms] <- 'deep'
```

# Determine environment in cells and environmental preferences in taxa

Rasterise points (should be equal area once projection supported)
```{r rasterise}
ll <- rast(resolution = 5, crs = 'epsg:4326')
prj <- 'ESRI:54030' # Robinson 
# 'EPSG:8858' # "+proj=moll" # 'EPSG:8857' equal earth
rob <- project(ll, prj) 
values(rob) <- 1:ncell(rob)

xyCartes <- c('paleolng','paleolat')
llColl <- vect(collSilur, geom = xyCartes, crs = 'epsg:4326')
robColl <- project(llColl, prj)
cellMat <- cells(rob, robColl) 
collSilur$cell <- cellMat[,'cell']
xyRob <- xyFromCell(rob, collSilur$cell)
cellXY <- c('cellX','cellY')
collSilur[,cellXY] <- xyRob
```

```{r plot enviro raster, fig.width=5.5, fig.align='center'}
bathRast <- classRast(rob, dat = collSilur, cutoff = 0.8,
                      xy = cellXY, env = 'bath')
plot(bathRast)
```

# Spatial standardisation of area and latitude

Split data by enviro category
```{r split occs by enviro class}
# infer environment of each occurrence
llOccs <- vect(occSilur, geom = xyCartes, crs = 'epsg:4326')
robOccs <- project(llOccs, prj)
occSilur$cell <- cells(rob, robOccs)[,'cell']
occSilur[,cellXY] <- xyFromCell(rob, occSilur$cell)
occSilur$bath <- extract(bathRast, robOccs)[['mainClass']] |> as.character()
deep <- occSilur[occSilur$bath == 'deep',]
prox <- occSilur[occSilur$bath == 'prox.',]
```

Regionally subsample each occurrence subset. 
Don't weight - not enough pool cells to matter much anyway.
```{r, error=TRUE}
reps <- 500
siteQuota <- 10
siteCol <- 'cell'
r <- 1000 # radial distance in km
sampD <- cookies(dat = deep, 
                  xy = cellXY, iter = reps, 
                  nSite = siteQuota, 
                  siteId = siteCol, r = r, 
                  crs = prj, output = 'full')
# we have to expand the subsample bounds to get enough sites!
r <- 1500
sampD <- cookies(dat = deep, 
                 xy = cellXY, iter = reps, 
                 nSite = siteQuota, 
                 siteId = siteCol, r = r, 
                 crs = prj, output = 'full')

# plot(bathRast)
# proxPts <- robOccs[robOccs$bath=='prox.',]
# points(proxPts)
sampP <- cookies(dat = prox, 
                 xy = cellXY, iter = reps, 
                 nSite = siteQuota, 
                 siteId = siteCol, r = r, 
                 crs = prj, output = 'full')
```

# Compare geographic range size across environments

```{r estimate vars from subsamples}
metaD <- sdsumry(dat = sampD, taxVar = 'genus', xy = cellXY, crs = prj)
metaP <- sdsumry(dat = sampP, taxVar = 'genus', xy = cellXY, crs = prj)
metaD$occAvg <- metaD$nOcc / metaD$nTax
metaP$occAvg <- metaP$nOcc / metaP$nTax
```

```{r boxplots, message = FALSE}
library(ggplot2)
plotDat <- rbind(metaD, metaP)
plotDat$bath <- c(rep('deep', nrow(metaD)), 
                  rep('prox', nrow(metaP)))
pBase <- ggplot(plotDat, aes(x = bath))
pBase + geom_boxplot(aes(x = bath, y = occAvg))
```

```{r var corrs}
# check out correlations betweeen all pairs of variables
vars <- c('minSpanTree','SCOR','occAvg','nTax')
cor(metaD[,vars], method = 'kendall')
```

```{r test diffs by enviro}
# NB: sorting strongly condenses the range of test statistic values
# and shifts from 0.5 to slightly less (because introduces ties (?))
nullSim <- function(dat1, dat2, vTest, vSort = NULL){
  # shuffle labels between test groups
  allDat <- rbind(dat1, dat2)
  n <- nrow(allDat) / 2
  hlf <- sample(sample(1:n*2), n, replace = FALSE)
  dat1null <- allDat[ hlf,]
  dat2null <- allDat[-hlf,]
  
  # optionally sort by second (sampling) variable
  if (! is.null(vSort)){
    ordr1 <- order(dat1null[, vSort])
    ordr2 <- order(dat2null[, vSort])
    dat1null <- dat1null[ordr1,]
    dat2null <- dat2null[ordr2,]
  }
  
  # (re)calculate test statistic
  v1null <- dat1null[, vTest]
  v2null <- dat2null[, vTest]
  sum(v2null > v1null) / n
}
# direction of test hypothesis here assumes group 2 values > group 1
# simulation also assumes groups 1 and 2 have equal sample size (n subsamples)

obsVsNull <- function(dat1, dat2, vTest, vSort = NULL, nullN){
  if ( !is.null(vSort) ){
    ordr1 <- order(dat1[, vSort])
    ordr2 <- order(dat2[, vSort])
    dat1 <- dat1[ordr1,]
    dat2 <- dat2[ordr2,]
  }
  h1obs <- dat2[, vTest] > dat1[, vTest]
  obsTestStat <- sum(h1obs) / nrow(dat1)
  nullDist <- replicate(nullN, nullSim(dat1, dat2, vTest, vSort))
  
  # hist(nullDist, xlim = c(0.4, 0.7)) # plot
  # abline(v = obsTestStat, col = 'blue')
  ci95 <- c(0.025, 0.975)
  null95 <- quantile(nullDist, ci95)
  names(null95) <- c('nullLwrCI', 'nullUprCI')
  # at what quantile of the null dist does the empirical test statistic lie?
  testQuantl <- sum(obsTestStat > nullDist) / nullN
  c(null95, 'obsTestStat' = obsTestStat, 'obsQuantl' = testQuantl)
}

# are shallows more diverse? (H: prox > deep) - yes
obsVsNull(metaD, metaP, vTest = 'nTax', nullN = 1000) # vSort = 'minSpanTree'

# are ranges broader in the deep? (H: deep > prox) - yes
obsVsNull(metaP, metaD, vTest = 'occAvg', nullN = 1000)

# can range-vs-enviro differences be explained by systematic differences
# in sampling between enviros? (H: deep > prox) - no
obsVsNull(metaP, metaD, vTest = 'minSpanTree', nullN = 1000)
```

```{r custom range size metrics}
# for testing purposes
  # taxa <- unique(occSilur$genus)
  # df <- sampD[[10]]
  # taxCol <- 'genus'
  # coordCols <- cellXY
  # crs <- prj
  #taxon <- 'Zygospiraella'

subsampRange <- function(taxa, df, taxCol, coordCols, crs){
  taxRange <- function(taxon){
    taxBool <- df[, taxCol] == taxon
    if (sum(taxBool) == 0){ # case where taxon unsampled
      rep(NA, 6)
    } else {
      taxCoords <- df[taxBool, coordCols]
      rangeSizer(taxCoords, crs)
    }
  }
  rngMat <- sapply(taxa, taxRange)
  rownames(rngMat) <- c('nOcc', 'centroidX', 'centroidY', 'latRange',
                        'greatCircDist', 'minSpanTree')
  rngDf <- data.frame(rngMat) |> t()
  rngMeans <- colMeans(rngDf, na.rm = TRUE)
  rngMeans[c('latRange', 'greatCircDist', 'minSpanTree')]
}
taxa <- unique(occSilur$genus)
# temp <- subsampRange(taxa, sampP[[1]], 'genus', cellXY, prj)

# TODO apply over all subsamples and add to other sdsumry data
```
